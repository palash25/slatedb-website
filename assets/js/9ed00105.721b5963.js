"use strict";(self.webpackChunkslatedb_website=self.webpackChunkslatedb_website||[]).push([[873],{2163:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var o=n(4848),s=n(8453);const i={sidebar_position:3},r="Configuration",a={id:"configuration",title:"Configuration",description:"Database Options",source:"@site/docs/configuration.md",sourceDirName:".",slug:"/configuration",permalink:"/docs/configuration",draft:!1,unlisted:!1,editUrl:"https://github.com/slatedb/slatedb-website/tree/main/docs/configuration.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Quickstart",permalink:"/docs/quickstart"},next:{title:"Architecture",permalink:"/docs/architecture"}},l={},c=[{value:"Database Options",id:"database-options",level:2},{value:"Read Options",id:"read-options",level:2},{value:"Write Options",id:"write-options",level:2},{value:"Compactor Options",id:"compactor-options",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"configuration",children:"Configuration"}),"\n",(0,o.jsx)(t.h2,{id:"database-options",children:"Database Options"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"/// Configuration options for the database. These options are set on client startup.\n#[derive(Clone)]\npub struct DbOptions {\n    /// How frequently to flush the write-ahead log to object storage (in\n    /// milliseconds).\n    ///\n    /// When setting this configuration, users must consider:\n    ///\n    /// * **Latency**: The higher the flush interval, the longer it will take for\n    ///   writes to be committed to object storage. Writers blocking on `put` calls\n    ///   will wait longer for the write. Readers reading committed writes will also\n    ///   see data later.\n    /// * **API cost**: The lower the flush interval, the more frequently PUT calls\n    ///   will be made to object storage. This can increase your object storage costs.\n    ///\n    /// We recommend setting this value based on your cost and latency tolerance. A\n    /// 100ms flush interval should result in $130/month in PUT costs on S3 standard.\n    ///\n    /// Keep in mind that the flush interval does not include the network latency. A\n    /// 100ms flush interval will result in a 100ms + the time it takes to send the\n    /// bytes to object storage.\n    pub flush_ms: usize,\n\n    /// How frequently to poll for new manifest files (in milliseconds). Refreshing\n    /// the manifest file allows writers to detect fencing operations and allows\n    /// readers to detect newly compacted data.\n    ///\n    /// **NOTE: SlateDB secondary readers (i.e. non-writer clients) do not currently\n    /// read from the WAL. Such readers only read from L0+. The manifest poll intervals\n    /// allows such readers to detect new L0+ files.**\n    pub manifest_poll_interval: Duration,\n\n    /// Write SSTables with a bloom filter if the number of keys in the SSTable\n    /// is greater than or equal to this value. Reads on small SSTables might be\n    /// faster without a bloom filter.\n    pub min_filter_keys: u32,\n\n    /// The minimum size a memtable needs to be before it is frozen and flushed to\n    /// L0 object storage. Writes will still be flushed to the object storage WAL\n    /// (based on flush_ms) regardless of this value. Memtable sizes are checked\n    /// every `flush_ms` milliseconds.\n    ///\n    /// When setting this configuration, users must consider:\n    ///\n    /// * **Recovery time**: The larger the L0 SSTable size threshold, the less\n    ///   frequently it will be written. As a result, the more recovery data there\n    ///   will be in the WAL if a process restarts.\n    /// * **Number of L0 SSTs**: The smaller the L0 SSTable size threshold, the more\n    ///   L0 SSTables there will be. L0 SSTables are not range partitioned; each is its\n    ///   own sorted table. As such, reads that don't hit the WAL or memtable will need\n    ///   to scan all L0 SSTables. The more there are, the slower the scan will be.\n    /// * **Memory usage**: The larger the L0 SSTable size threshold, the larger the\n    ///   unflushed in-memory memtable will grow. This shouldn't be a concern for most\n    ///   workloads, but it's worth considering for workloads with very high L0\n    ///   SSTable sizes.\n    /// * **API cost**: Smaller L0 SSTable sizes will result in more frequent writes\n    ///   to object storage. This can increase your object storage costs.\n    /// * **Secondary reader latency**: Secondary (non-writer) clients only see L0+\n    ///   writes; they don't see WAL writes. Thus, the higher the L0 SSTable size, the\n    ///   less frequently they will be written, and the longer it will take for\n    ///   secondary readers to see new data.\n    ///\n    /// We recommend setting this value to a size that will result in one L0 SSTable\n    /// per-second. With a default compaction interval of 5 seconds, this will result\n    /// in 4 or 5 L0 SSTables per compaction. Thus, a writer putting 10MiB/s of data\n    /// would configure this value to 10 * 1024 * 1024 = 10_485_760 bytes.\n    pub l0_sst_size_bytes: usize,\n\n    /// Configuration options for the compactor.\n    pub compactor_options: Option<CompactorOptions>,\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"read-options",children:"Read Options"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"/// Whether reads see data that's been written to object storage.\npub enum ReadLevel {\n    /// Client reads will only see data that's been written to object storage.\n    Commited,\n\n    /// Clients will see all writes, including those not yet written to object\n    /// storage.\n    Uncommitted,\n}\n\n/// Configuration for client read operations. `ReadOptions` is supplied for each\n/// read call and controls the behavior of the read.\npub struct ReadOptions {\n    /// The read commit level for read operations.\n    pub read_level: ReadLevel,\n}\n\nimpl ReadOptions {\n    /// Create a new ReadOptions with `read_level` set to `Commited`.\n    const fn default() -> Self {\n        Self {\n            read_level: ReadLevel::Commited,\n        }\n    }\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"write-options",children:"Write Options"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"/// Configuration for client write operations. `WriteOptions` is supplied for each\n/// write call and controls the behavior of the write.\npub struct WriteOptions {\n    /// Whether `put` calls should block until the write has been written to\n    /// object storage.\n    pub await_flush: bool,\n}\n\nimpl WriteOptions {\n    /// Create a new `WriteOptions`` with `await_flush` set to `true`.\n    const fn default() -> Self {\n        Self { await_flush: true }\n    }\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"compactor-options",children:"Compactor Options"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-rust",children:"/// Options for the compactor.\n#[derive(Clone)]\npub struct CompactorOptions {\n    /// The interval at which the compactor checks for a new manifest and decides\n    /// if a compaction must be scheduled\n    pub(crate) poll_interval: Duration,\n\n    /// A compacted SSTable's maximum size (in bytes). If more data needs to be\n    /// written during a compaction, a new SSTable will be created when this size\n    /// is exceeded.\n    pub(crate) max_sst_size: usize,\n}\n\n/// Default options for the compactor. Currently, only a\n/// `SizeTieredCompactionScheduler` compaction strategy is implemented.\nimpl CompactorOptions {\n    /// Returns a `CompactorOptions` with a 5 second poll interval and a 1GB max\n    /// SSTable size.\n    pub const fn default() -> Self {\n        Self {\n            poll_interval: Duration::from_secs(5),\n            max_sst_size: 1024 * 1024 * 1024,\n        }\n    }\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var o=n(6540);const s={},i=o.createContext(s);function r(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);